                    ________________                     ______  
                    __  __ \_  ____/____________ ___________  /_ 
                    _  / / /  / __ __  ___/  __ `/__  __ \_  __ \
                    / /_/ // /_/ / _  /   / /_/ /__  /_/ /  / / /
                    \____/ \____/  /_/    \__,_/ _  .___//_/ /_/ 
    			                                 /_/             

# OGraph: A simple way to build a pipeline with Go

[![Go Report Card](https://goreportcard.com/badge/github.com/symphony09/ograph)](https://goreportcard.com/report/github.com/symphony09/ograph)
[![codecov](https://codecov.io/github/symphony09/ograph/graph/badge.svg?token=TR5UR9L6Y8)](https://codecov.io/github/symphony09/ograph)
[![Go Reference](https://pkg.go.dev/badge/github.com/symphony09/ograph.svg)](https://pkg.go.dev/github.com/symphony09/ograph)
[![DeepWiki](https://img.shields.io/badge/DeepWiki-symphony09%2Fograph-blue.svg?logo=data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACwAAAAyCAYAAAAnWDnqAAAAAXNSR0IArs4c6QAAA05JREFUaEPtmUtyEzEQhtWTQyQLHNak2AB7ZnyXZMEjXMGeK/AIi+QuHrMnbChYY7MIh8g01fJoopFb0uhhEqqcbWTp06/uv1saEDv4O3n3dV60RfP947Mm9/SQc0ICFQgzfc4CYZoTPAswgSJCCUJUnAAoRHOAUOcATwbmVLWdGoH//PB8mnKqScAhsD0kYP3j/Yt5LPQe2KvcXmGvRHcDnpxfL2zOYJ1mFwrryWTz0advv1Ut4CJgf5uhDuDj5eUcAUoahrdY/56ebRWeraTjMt/00Sh3UDtjgHtQNHwcRGOC98BJEAEymycmYcWwOprTgcB6VZ5JK5TAJ+fXGLBm3FDAmn6oPPjR4rKCAoJCal2eAiQp2x0vxTPB3ALO2CRkwmDy5WohzBDwSEFKRwPbknEggCPB/imwrycgxX2NzoMCHhPkDwqYMr9tRcP5qNrMZHkVnOjRMWwLCcr8ohBVb1OMjxLwGCvjTikrsBOiA6fNyCrm8V1rP93iVPpwaE+gO0SsWmPiXB+jikdf6SizrT5qKasx5j8ABbHpFTx+vFXp9EnYQmLx02h1QTTrl6eDqxLnGjporxl3NL3agEvXdT0WmEost648sQOYAeJS9Q7bfUVoMGnjo4AZdUMQku50McDcMWcBPvr0SzbTAFDfvJqwLzgxwATnCgnp4wDl6Aa+Ax283gghmj+vj7feE2KBBRMW3FzOpLOADl0Isb5587h/U4gGvkt5v60Z1VLG8BhYjbzRwyQZemwAd6cCR5/XFWLYZRIMpX39AR0tjaGGiGzLVyhse5C9RKC6ai42ppWPKiBagOvaYk8lO7DajerabOZP46Lby5wKjw1HCRx7p9sVMOWGzb/vA1hwiWc6jm3MvQDTogQkiqIhJV0nBQBTU+3okKCFDy9WwferkHjtxib7t3xIUQtHxnIwtx4mpg26/HfwVNVDb4oI9RHmx5WGelRVlrtiw43zboCLaxv46AZeB3IlTkwouebTr1y2NjSpHz68WNFjHvupy3q8TFn3Hos2IAk4Ju5dCo8B3wP7VPr/FGaKiG+T+v+TQqIrOqMTL1VdWV1DdmcbO8KXBz6esmYWYKPwDL5b5FA1a0hwapHiom0r/cKaoqr+27/XcrS5UwSMbQAAAABJRU5ErkJggg==)](https://deepwiki.com/symphony09/ograph)
<!-- DeepWiki badge generated by https://deepwiki.ryoppippi.com/ -->


[中文](README.md) | [English](README_en.md)

**OGraph** is a graph execution framework implemented in Go.

You can control the scheduling of sequential execution of dependent elements and concurrent execution of non-dependent elements by building a `Pipeline`.

In addition, OGraph also provides a range of features out-of-the-box, including retry limits, timeout settings, and execution tracking.

## Comparison with similar projects

**OGraph** was inspired by another C++ project, [CGraph](https://github.com/ChunelFeng/CGraph). However, OGraph is not the Go version of CGraph.

### Feature Comparison

Like CGraph, OGraph also provides basic graph construction and scheduling execution capabilities. However, there are several key differences:

*   Implemented in Go, using coroutines instead of threads for scheduling, making it lighter and more flexible.

*   Supports customizing loop, condition, error handling, and other logic through `Wrapper`, which can be combined freely.

*   Supports exporting graph structure and importing it for execution (within the constraints).

*    Flexible virtual node settings to simplify dependencies.

### Performance Comparison

After benchmarking, the performance of OGraph and CGraph are on the same level. However, OGraph has an advantage in performance in io-intensive scenarios.

[CGraph Performance test reference](http://www.chunel.cn/archives/cgraph-compare-taskflow-v1)

OGraph Performance test reference

Limit: 8 cores, three scenarios (concurrent 32 nodes, sequential 32 nodes, complex scenario simulating 6 nodes) each executed 1 million times.

```bash
cd test
go test -bench='(Concurrent_32|Serial_32|Complex_6)$' -benchtime=1000000x -benchmem -cpu=8
```

outputs

    goos: linux
    goarch: amd64
    pkg: github.com/symphony09/ograph/test
    cpu: AMD Ryzen 5 5600G with Radeon Graphics         
    BenchmarkConcurrent_32-8         1000000              9669 ns/op            2212 B/op         64 allocs/op
    BenchmarkSerial_32-8             1000000              1761 ns/op             712 B/op         15 allocs/op
    BenchmarkComplex_6-8             1000000              3118 ns/op            1152 B/op         26 allocs/op
    PASS
    ok      github.com/symphony09/ograph/test       14.553s

## Quick Start

### Step 1: Declare a Node interface implementation.

```go
type Person struct {
	ograph.BaseNode
}

func (person *Person) Run(ctx context.Context, state ogcore.State) error {
	fmt.Printf("Hello, i am %s.\n", person.Name())
	return nil
}
```

In the code above, the Person struct combines the BaseNode and overrides the Node interface method Run.

### Step 2: Build a Pipeline and run it.

```go
func TestHello(t *testing.T) {
	pipeline := ograph.NewPipeline()

	zhangSan := ograph.NewElement("ZhangSan").UseNode(&Person{})
	liSi := ograph.NewElement("LiSi").UseNode(&Person{})

	pipeline.Register(zhangSan).
		Register(liSi, ograph.Rely(zhangSan))

	if err := pipeline.Run(context.TODO(), nil); err != nil {
		t.Error(err)
	}
}
```

In the code above, the two Person nodes (zhangSan and liSi) in the pipeline are registered, and liSi is specified to depend on zhangSan.

outputs

    Hello, i am ZhangSan.
    Hello, i am LiSi.

## More Documents

Please follow the documentation at [https://symphony09.github.io/ograph-docs](https://symphony09.github.io/ograph-docs/docs/quick-start/)!